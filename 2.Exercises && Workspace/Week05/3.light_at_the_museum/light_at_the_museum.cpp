#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <climits>

typedef std::pair<int, int> PII;
typedef std::vector<int> VI;
typedef std::vector<PII> VPII;
typedef std::vector<VPII> VVPII;
typedef std::map<VI, int> MVII;

MVII acheivable_brightnesses(VVPII& initial_states) { // acheivable brightnesses in a certain room using switches 0 to n/2 or n/2 to n
	int n = initial_states.size();
	int m = initial_states[0].size(); // number of rooms
	MVII brightnesses_min_flicks; // each represents the brightnesses achievable at the same time (i,e with same switches state) and is mapped to the min_flicks to achieve this array of rooms brightnesses	
	
	for(int i=0; i< 1<<n; i++) { // each state of switches (encoded in i) generates a certain brightness in each of the m rooms, we find for each room the brightness generated by state i
		VI brightnesses(m, 0); // brightnesses with the current state of switches
		int flicked_switches = 0;
		// bit j = 0 => switch j isn't flicked => initially on lamps are on
		// bit j = 1 => switch j is flicked => initially off lamps are on (and we add it to flicked switches)
		for(int j=0; j<n; j++) {
			if(i & 1<<j) { // j'th bit is 1 (i,e j'th switch flicked => add brightness of "initially off lamps")
				for(int k=0; k<m; k++) // add brightness to each room
					brightnesses[k] += initial_states[j][k].second;
					
				flicked_switches++;
			} else { // j'th bit is 0 (i,e j'th switch not flicked => add brightness of "initially on lamps")
				for(int k=0; k<m; k++)
					brightnesses[k] += initial_states[j][k].first;
					
			}
		}
		
		MVII& m(brightnesses_min_flicks); // just rename brightnesses_min_flicks to m
		auto it = m.find(brightnesses);
		if(it != m.end()) {
			it->second = std::min(it->second, flicked_switches);
		} else
			m[brightnesses] = flicked_switches;
	}
	return brightnesses_min_flicks;
}

int find_min_flicks(VVPII& initial_states, VI& target_brightnesses) {
	int n = initial_states.size();
	int m = initial_states[0].size();
	// we split the switches into 2 disjoint and independant sets
	VVPII initial_states_1;
	VVPII initial_states_2;
	for(int i=0; i<n; i++) {
		if(i<n/2)
			initial_states_1.push_back(initial_states[i]);
		else
			initial_states_2.push_back(initial_states[i]);
	}
	MVII map1 = acheivable_brightnesses(initial_states_1);
	MVII map2;
	if(!initial_states_2.empty()) { // empty when n=1
		map2 = acheivable_brightnesses(initial_states_2);
	} else { // if empty then we only check map1 if it contains the target_brightnesses
		if(map1.find(target_brightnesses) != map1.end())
			return map1[target_brightnesses];
		else 
			return -1;
	}
	
	int min_flicks = -1;
	for(auto it1 = map1.begin(); it1 != map1.end(); it1++) {
		VI brightnesses1 = it1->first;
		VI brightnesses2(m);
		for(int i=0; i<m; i++) {
			brightnesses2[i] = target_brightnesses[i] - brightnesses1[i];
		}
		auto it2 = map2.find(brightnesses2); // check if target brightnesses achievable
		if(it2 != map2.end()) { // yes acheivable
			int flicks = it1->second + it2->second;
			min_flicks = (min_flicks == -1 ? flicks : std::min(min_flicks, flicks));
		}
	}
	return min_flicks;
}

void testcase() {
	int n, m; std::cin >> n >> m; // n: #switches, m: #rooms 1 <= n,m <= 30
	
	VI target_brightnesses(m);
	for(int i=0; i<m; i++) {
		int b; std::cin >> b;
		target_brightnesses[i] = b;
	}
	
	// for each switch, we store the initial #lamps than are on and those that are off
	VVPII initial_states(n, VPII(m));

	for(int i=0; i<n; i++) { // switches i
		for(int j=0; j<m; j++) { // rooms j
			int on, off; std::cin >> on >> off; // total=on+off is #lamps of room j connected to switch i
			// on = #lamps initially on -- off = #lamps initially off
			initial_states[i][j] = PII(on, off);
		}
	}
	
	int min_flicks = find_min_flicks(initial_states, target_brightnesses);
	
	if(min_flicks == -1)
		std::cout << "impossible" << std::endl;
	else
		std::cout << min_flicks << std::endl;
	
}

int main() {
	std::ios_base::sync_with_stdio(false);
	
	int t; std::cin >> t;
	while(t--) testcase();
	return 0;
}
